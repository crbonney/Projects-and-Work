function [Self] = design_pid(DesignPlant, AnalysisPlant, Pvalues, Ivalues, Dvalues, Self)%% Purpose:% to pick gains of and build a control law in common-controller form of a% PID controller. It picks the coefficients by iteratively designing and testing% coefficients for P, I and D, and picks the best by selecting the one % with the minimum sum of squared rise time and settle time% it also analyzes the system's robustness using the design_metrics% function%% Inputs:% DesignPlant - state-space model of the system used to design a% controller% % AnalysisPlant - state-space model of the system used for analysis of the% control design%% PIDvalues - a 3D array of values to test for P, I and D%% Self - a structure containing information about the system, controller% design, and stability/robustness metrics%% Outputs: % Self - same as above% make sure DesignPlant and AnalysisPlant are included in the outputSelf.DesignPlant = DesignPlant;Self.AnalysisPlant = AnalysisPlant;Self.Pvalues = Pvalues;Self.Ivalues = Ivalues;Self.Dvalues = Dvalues;%% Build system matrix that includes the robust servo integratorCcmd = DesignPlant.C(1,:);Dcmd = DesignPlant.D(1,:);Self.Aw = [zeros(1,1)      Ccmd      ;            zeros(size(DesignPlant.A,1),1)  DesignPlant.A];Self.Bw = [Dcmd;   DesignPlant.B];% octave change: meshgrid swaps P and I values for some reason# [P,I,D] = meshgrid(Pvalues,Ivalues,Dvalues);[P,I,D] = meshgrid(Ivalues,Pvalues,Dvalues);% empty arrays to store metrics of different LQR designsrise_time_ijk = 0.*P + 100000; % rise timesettle_time_ijk = 0.*P + 100000; % settle timeny_analysis = size(AnalysisPlant.C,1);ny_design = size(DesignPlant.C,1);for i=1:length(Pvalues)  for j=1:length(Ivalues)    for k=1:length(Dvalues)      PID_ijk = [P(i,j,k),I(i,j,k),D(i,j,k)];      Ctrl.Ac  = 0;      Ctrl.Bc1 = zeros(1,ny_analysis);      Ctrl.Bc1(1) = -1;      Ctrl.Bc2 = [1];      Ctrl.Cc  = [-PID_ijk(1)];      Ctrl.Dc1 = zeros(1,ny_analysis);      Ctrl.Dc1(1:2) = [PID_ijk(2:3)];      Ctrl.Dc2 = [-PID_ijk(2)];      sys_cl = cl_system(AnalysisPlant,Ctrl);                  if (max(real(eig(sys_cl.A))) > 0) %unstable controller        disp("unstable: ");        fdisp (stdout, [PID_ijk; i, j, k]);        disp(eig(sys_cl.A));        continue;      end      Design = design_metrics(AnalysisPlant,Ctrl);      design_ijk(i,j,k) = Design;      rise_time_ijk(i,j,k) = Design.risetime;      settle_time_ijk(i,j,k) = Design.settletime;          end  endendassert(exist('design_ijk','var') == true,'Could not find a stable controller design.');% pick best designsquare_times = rise_time_ijk.^2 + settle_time_ijk.^2;[~,best_ijk] = min(square_times(:));[best_i,best_j,best_k] = ind2sub(size(square_times),best_ijk);best_P = P(best_i,best_j,best_k);best_I = I(best_i,best_j,best_k);best_D = D(best_i,best_j,best_k);% Build Controller in Classical Form  PID_ijk = [best_P,best_I,best_D];  Ctrl.Ac  = 0;  Ctrl.Bc1 = zeros(1,ny_analysis);  Ctrl.Bc1(1) = -1;  Ctrl.Bc2 = [1];  Ctrl.Cc  = [-PID_ijk(1)];  Ctrl.Dc1 = zeros(1,ny_analysis);  Ctrl.Dc1(1:2) = [PID_ijk(2:3)];  Ctrl.Dc2 = [-PID_ijk(2)];  %% Return design analsis, and all the controllers testedSelf.t = Design.t;Self.Controller = Ctrl; % classical controller form of picked designSelf.Design_data = design_ijk; % analysis of all controllersSelf = design_metrics(AnalysisPlant,Self.Controller,Self); %metricsSelf.best_ijk = best_ijk;Self.best_PID = [best_P,best_I,best_D];end